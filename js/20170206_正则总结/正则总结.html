<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="">
</head>
<body>
    <h3>正则归纳总结</h3>
    <div>
        <pre>
            如何使用正则表达式，直接量：
                var rxgexp = /.../;
            使用RegExp构造函数创建正则对象:
                var regexp = new RegExp('...');第一个参数是过滤条件，当使用转义字符时需要在转义字符前加\。
                如:new RegExp('\\d*'),第二个参数是可选修饰符。
            直接量字符：
               字符           匹配
            字母和数字         自身
            \o                NUL字符（\u0000）
            \t                制表符
            \n                换行符
            \v                垂直制表符
            \f                换页符
            \r                回车符
            字符类：
             []            括号中任意字符
             [^]           非括号中任意字符
             .             除了换行符和终止符的任意字符
             \w            [a-z0-9A-Z]
             \W            [^a-z0-9A-Z]
             \s            空白符
             \S            非空白符
             \d            [0-9]
             \D            [^0-9]
            注：总是迷糊^什么时候是非的意思什么时候是以什么开头，看来如果^在[]方括号中，意思为非，否则为以什么开头的意思。
            重复：
            {n,m}           至少n次，最多m次
            {n,}            至少n次，多了不限
            {n}             匹配n次
            ?               一次或没有，可选的
            *               0次或多次
            +               1次或多次
            非贪婪：
            上面的重复都是贪婪重复会尽可能多的匹配，而非贪婪模式与其相反，尽可能少的匹配满足的字符，
            方法是在上面重复字符后加？，如*?,+?。
            选择分组和引用：
            a|b          匹配a或者b
            （）         将匹配的字符当作子表达式，记忆匹配的字符，用于引用和正则方法$引用
            （？：）      只组合，不记忆匹配的字符
            \n           和第n个分组的第一次匹配的字符相匹配
            用于模式匹配的String方法：
            search
            match
            replace
            split
            RegExp方法
            exec
            test
        </pre>

    </div>
</body>
</html>